# Finding SQLI
___

### Black box testing

Step 1. Mapping
>Explore the URL, locating all the input vectors that could potentially communicate with a database.
Work out how the URL works and what is the intended purpose. Figure out the logic, look for subdomains.
Have Burp running in the background capturing the traffic. Scan for directories looking for interesting files and locations.

Step 2. Fuzzing
>Fuzzing the application with specific SQL characters. ie.__' " -- ;__ look for errors and other potential flags. Depending on how the application responds you can refine the query until injection is successful.
Errors can be useful as they can sometimes give away information about the database you are working with. This is helpful as it narrows down how you fuzz the database as different databases handle queries differently. They may also give away the actual query.
1. Submit boolean queries and try to invoke errors. ie __OR 1=1__, __OR 1=2__. Have a look and see how each query differs from each other. If they respond differently then the application may be vulnerable to Boolean based injection.
2. Submit time delay payloads within the SQL query and see how they respond. If you set a time delay and the application observes the delay then the app may be vulnerable to time based injection.
3. Submit out of band payloads designed to trigger OOB network interaction when executed, Monitor this from a server you control. If we capture a DNS lookup or through HTTP then the application may be vulnerable to OOB injection.

### White box testing
NOTE... This is where we may be given the source code.

Step 1. Enable web server and database logging.
>Web server logging is useful because it will log all the errors with invalid characters inputted, this helps to check if sql exists and can assist in the payload design. Database logging is useful if there is a potential for injection it logs all the queries, depending on how its logged you can see what characters made it through and which format was used. This can determine if the app is vulnerable to injection.

Step 2. Mapping
>This is done in the same way as black box. Then because we have access to the source we can use a regex search on all instances in the code that talks to the database. this is dependent on how its designed and which databases are used.

Step 3. Code Review
>Follow the code path for all input vectors. Test any potential SQLI vulnerabilities.
